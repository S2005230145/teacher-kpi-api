akka {
  actor {
    warn-about-java-serializer-usage = false
    default-dispatcher {
      # This will be used if you have set "executor = "fork-join-executor""
      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 4
        # The parallelism factor is used to determine thread pool size using the
        # following formula: ceil(available processors * factor). Resulting size
        # is then bounded by the parallelism-min and parallelism-max values.
        parallelism-factor = 2.0
        # Max number of threads to cap factor-based parallelism number to
        parallelism-max = 16
        # Setting to "FIFO" to use queue like peeking mode which "poll" or "LIFO" to use stack
        # like peeking mode which "pop".
        task-peeking-mode = "FIFO"
      }
    }
    serializers {
      jackson-json = "akka.serialization.jackson.JacksonJsonSerializer"
      proto = "akka.remote.serialization.ProtobufSerializer"
    }
    serialization-bindings {
      "io.ebean.Model" = jackson-json
      "com.fasterxml.jackson.databind.JsonSerializable" = jackson-json
      "com.google.protobuf.Message" = proto
    }
  }
  loglevel = "INFO"
  stdout-loglevel = "INFO"
}
akka.actor.allow-java-serialization = true
akka.actor.serialize-messages = off
akka.actor.NoSerializationVerificationNeeded = true
play.http.secret.key = "XdskielxcsIPSDf;sjdxcsdpiwer;xcvsdfilklexxviolkxdfXv-0902923sdf"
play.modules {
}
play.i18n {
  # The application languages
  langs = ["en"]
}

## Play HTTP settings
# ~~~~~
play.http {
  errorHandler = null
  session {
  }

  flash {
  }
}

## Netty Provider
# https://www.playframework.com/documentation/latest/SettingsNetty
# ~~~~~
play.server.netty {
  # Whether the Netty wire should be logged
  #log.wire = true

  # If you run Play on Linux, you can use Netty's native socket transport
  # for higher performance with less garbage.
  transport = "native"
}

play.ws {
  ssl {
  }
}

play.cache {
  # If you want to bind several caches, you can bind the individually
  #bindCaches = ["db-cache", "user-cache", "session-cache"]
  redis.bindCaches = ["db-cache", "user-cache", "session-cache"]
}

evolutionplugin = enabled
play.evolutions {
  # You can disable evolutions for a specific datasource if necessary
  db.default.enabled = false
}

## Database Connection Pool
# https://www.playframework.com/documentation/latest/SettingsJDBC
# ~~~~~
# Play doesn't require a JDBC database to run, but you can easily enable one.
#
# libraryDependencies += jdbc
#
play.db {
  # The combination of these two settings results in "db.default" as the
  # default JDBC pool:
  config = "db"
  default = "default"
  # Play uses HikariCP as the default connection pool.  You can override
  # settings by changing the prototype:
  prototype {
    # Sets a fixed JDBC connection pool size of 50
    #hikaricp.minimumIdle = 50
    #hikaricp.maximumPoolSize = 50
  }
}

## JDBC Datasource
# https://www.playframework.com/documentation/latest/JavaDatabase
# https://www.playframework.com/documentation/latest/ScalaDatabase
# ~~~~~
# Once JDBC datasource is set up, you can work with several different
# database options:
#
# Slick (Scala preferred option): https://www.playframework.com/documentation/latest/PlaySlick
# JPA (Java preferred option): https://playframework.com/documentation/latest/JavaJPA
# EBean: https://playframework.com/documentation/latest/JavaEbean
# Anorm: https://www.playframework.com/documentation/latest/ScalaAnorm
#
ebean.default = "models.*"
# Number of database connections
# See https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing
fixedConnectionPool = 9

# Set Hikari to fixed size
play.db {
  prototype {
    hikaricp.minimumIdle = ${fixedConnectionPool}
    hikaricp.maximumPoolSize = ${fixedConnectionPool}
  }
}
# Job queue sized to HikariCP connection pool
database.dispatcher {
  executor = "thread-pool-executor"
  throughput = 1
  thread-pool-executor {
    fixed-pool-size = ${fixedConnectionPool}
  }
}

db {
  default.driver=com.mysql.cj.jdbc.Driver
  default.url="jdbc:mysql://127.0.0.1:3306/teacher_kpi?characterEncoding=UTF-8&useSSL=false&serverTimezone=GMT%2B8"
  default.username=root
  default.password="123456"
  default.host="127.0.0.1"
  # You can turn on SQL logging for any datasource
  # https://www.playframework.com/documentation/latest/Highlights25#Logging-SQL-statements
  default.logSql=false
}
play.modules.enabled += "play.api.cache.redis.RedisCacheModule"
play.modules.enabled += service.CustomCacheModule
play.cache.redis {
  bind-default: false
  default-cache: "redis"
  source = custom
  host = 127.0.0.1
  # redis server: port
  port = 6379
  # redis server: database number (optional)
  database = 0
  # authentication password (optional)
  password = "123456"
  refresh-minute = 10
}
#play.http.actionCreator = "handlers.ApiCheckActionCreator"
play.filters.enabled += play.filters.hosts.AllowedHostsFilter
play.filters.hosts {
  # Allow requests to example.com, its subdomains, and localhost:9000.
  allowed = ["wm.bxnet.net"]
}

play.ws.compressionEnabled = true
play.ws.timeout.connection = 20s
play.ws.timeout.idle = 20s
play.ws.timeout.request = 30s
play.ws.ahc.maxConnectionsPerHost = 100000
play.ws.ahc.maxConnectionsTotal = 1000000

play.allowGlobalApplication = true
play.akka.actor-system = "app"

play.filters.disabled += play.filters.csrf.CSRFFilter

#验证码模板
sms_content_template = ""
sms_alert_content = ""
sms_charge_prompt = ""
sms_charge_result = ""
sms_consume_notify = ""
#一个用户每天最大发送数量
sms_limit_maxsend_by_day = 20
#短信用户名
sms_user_name = user_name
#短信密码
sms_password = 123
#短信失效时间,秒为单位，默认为30分钟
sms_expire_time = 1800
###TODO 正式上线要改成 1800 30分钟
token_expire_time = 18000
play.allowGlobalApplication = false
play.http.filters = filters.Filters
upload_path = "/home/upload/"
nginx_path = "/home/web/"
play.filters.csrf.header.bypassHeaders {
  X-Requested-With = "*"
  Csrf-Token = "nocheck"
}
play.filters.enabled += "play.filters.gzip.GzipFilter"
play.filters.gzip.compressionLevel = 9
play.filters.gzip {
  contentType {
    # If non empty, then a response will only be compressed if its content type is in this list.
    whiteList = ["text/*", "application/javascript", "application/json"]
    # The black list is only used if the white list is empty.
    # Compress all responses except the ones whose content type is in this list.
    blackList = []
  }

}
fileUpload{
    windows="E:/"
    linux="/home/ubuntu/web/"
}